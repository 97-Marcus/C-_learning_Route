#include <stdio.h>
#include <stdlib.h>

//栈区
//堆区
//全局静态区
//字符常量区


/*

//栈区
//一个大括号就是一个作用域，在作用域内声明的变量为局部变量，局部变量存储在栈区中。
//局部变量的生命周期：声明时到作用域结束时
//使用范围：所在作用域内

int* AA();

int main() 
{
	int* p = AA();
	printf("%d\n", *p);//第一次读到了，但是第二次开始输出之前已经被系统回收了
	printf("%d\n", *p);
	printf("%d\n", *p);
	printf("%d\n", *p);

	return 0;
}

int* AA()	
{
	int a = 100;
	return &a;	//返回局部变量或者临时变量的地址
}
*/



//堆区：手动申请的空间
//生命周期：申请时出生，释放时消亡（①手动释放free时 ②程序结束时）



//int* AA();
//
//int main() 
//{
//	int* p = (int*)malloc(4);
//	//malloc返回的是void*类型的，所以使用强制类型转换，注意并不是真的转换了，只是欺骗编译器消除错误而已
//	//申请的空间是连续的,验证程序如下：
//
//	/*
//	char *p = (char*)malloc(4);
//	int i;
//	p[0] = 'a';
//	p[1] = 'b';
//	p[2] = 'c';
//	p[3] = 'd';
//
//	for(i=0;i<4;i++)
//	{
//		printf("%c\n",p[i]);
//	}*/
//
//	/*
//	printf("%d\n", *p);
//	*p = 100;
//	printf("%d\n", *p);
//	*/
//
//	int* p1 = AA();
//	printf("%d\n", *p1);
//	printf("%d\n", *p1);
//	free(p1);//不可以释放第二次
//	printf("%d\n", *p1);
//	printf("%d\n", *p1);
//	//全都是10，AA栈区被回收，但malloc堆区没有被系统回收
//}
//
//int* AA()
//{
//	int* p1 = (int*)malloc(4);
//	*p1 = 10;
//	//free(p1);//释放后就没有内容了，输出的就是乱码~
//	return p1;
//}



//全局静态区（存储全局变量和静态变量）

/*
//全局变量
int a;//定义在作用域外的变量叫全局变量
	  //生命周期：程序运行时出生，程序结束时消亡
	  //使用范围：整个程序
	  //默认初始化为0，也可以自行初始化为其他值

int* AA();

int main()
{
	int* p = NULL;
	printf("%d\n", a);

	p = AA();
	printf("%d\n", *p);
	printf("%d\n", *p);	
	printf("%d\n", *p);	

	return 0;
}

int* AA()
{
	//int a;	//当出现局部变量和全局变量重名时，优先识别局部变量
	a = 100;
	return &a;
}

*/



//静态变量
//生命周期：程序运行时出生，程序结束时消亡
//使用范围：所在作用域内
//默认初始化为0，只初始化一次


//int* AA();
//
//int main()
//{
//	int* p = NULL;
//
//	/*
//	p = AA();
//	printf("%d\n", *p);
//	printf("%d\n", *p);
//	printf("%d\n", *p);	
//	printf("%d\n", *p);//四次输出中AA函数只运行了一次
//	*/
//
//	printf("%d\n", *AA());	
//	printf("%d\n", *AA());	
//	printf("%d\n", *AA());	
//	printf("%d\n", *AA());//四次输出中AA函数运行了四次
//						  //如果AA中不使用静态变量，那么四次都输出0
//
//	return 0;
//}
//
//int* AA()
//{
//	static int a;	//静态变量
//	//a = 100;
//	a++; //如果不使用静态变量，那么四次都输出1;使用后程序输出1234
//		 //由于静态变量只初始化一次，并且不随着定义域而回收
//		 //因此不会被覆盖为0再进行a++输出1，而是在每次程序运行完后继续对a进行累加。
//	return &a;
//}