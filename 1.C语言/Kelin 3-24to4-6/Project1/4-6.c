#include <stdio.h>

//指针数组：即数组（每一个元素都是指针的数组）
/*
int main() 
{
	int a = 10;
	int b = 20;
	int c = 30;
	int d = 40;
	int e = 50;

	int* arr[5] = { &a,&b,&c,&d,&e };
	int i;

	for (i=0;i<5;i++)
	{
		//printf("%d\n", *arr[i]);
		printf("%d\n", arr[i][0]);	
      //arr表示数组首元素的地址，arr[i]是以首元素的大小为单位（4个字节）偏移i个单位，然后间接引用这个数组，得到该元素
      //[0]是因为该元素本身也是地址，所以进行再次间接引用，得到其地址上的内容
		//不能使用arr[0][i]的原因是：尽管&a的地址和&b的地址连续，但是a和b的地址不连续，所以读不到值。
	}
	return 0;
}
*/

//检验程序1
/*
int main()
{
	int arr1[] = { 10, 20, 30, 40, 50 };
	int* arr[] = { &arr1[0], &arr1[1], &arr1[2], &arr1[3], &arr1[4] };

	for (int i = 0; i < 5; i++)
	{
		printf("%d\n", arr[i][0]);
	}
	return 0;
}
*/



//只要有变量就得有空间，有空间就得有地址
//数组指针
//要求：通过p遍历数组(突破点：先拿到首元素的地址)
/*
int main()
{
	int arr[5] = { 10,20,30,40,50 };
	int(*p)[5] = &arr;//去掉变量名即为类型，所以是int(*)[5]类型

	//printf("%d\n", sizeof(int(*)[5]));//指针类型：字节4
	//printf("%d\n", sizeof(int* [5]));//数组类型：字节4*5=20
	//如果去掉变量名后小括号内还有东西，说明意义不一样，不能去掉括号

	int i;
	for (i=0;i<5;i++)
	{
		//printf("%d\n", (*p)[i]);
		printf("%d\n", p[0][i]);
		//p[0]的意思是：偏移0个字节，获得首元素的地址，再偏移i*4个字节，再间接引用得到内容
		//如果是p[i][0],那么第一步偏移了整个数组的字节长度，所以后面无法正常进行
		printf("%d\n", *((*p) + i);
		//p是数组指针，指向的是整个数组的地址，*p是数组首元素地址，+i是进行i*4个字节的偏移得到后面几个元素的地址然后再取*得到内容
	}
	return 0;
}
*/


//冒泡排序	//循环次数为需要比较的次数-1
/*
int main()
{
	int arr[10] = { 4,2,7,4,6,8,3,2,2,9 };
	int i, j;
	int temp;
	int count=0;

	for (j = 0; j < 10 - 1; j++) 
	{
		//for (i = 0; i < 10; i++)	//i=10的时候，最后一个9和后面四个不属于自己的字节进行了交换，发生错误。应该改成i<10-1
		for (i = 0; i < 10-1; i++)
		for (i = 0; i < 10 - 1 - j; i++) //第一次循环中最大的数在最后一位，因此第二轮倒数第二个数无需和最后一位兑换，以此类推，第n次j的循环就可以免n次的i进行加减，所以i<10-1-j。
		{
			if (arr[i] > arr[i + 1])
			{
				temp = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = temp;
			}
			count++;
		}
	}
	
	for (i = 0; i < 10; i++) 
	{
		printf("%d\t", arr[i]);
	}

	printf("\n%d", count);
	return 0;
}
*/



//二维数组
/*
int main() 
{
	int arr1[2][3] = { 1,2,3,4,5,6 };
	int arr2[2][3] = { {1,2,3},{4,5,6} };
	//两种完全定义的方法，实际上这个二维数组当中仅有两个元素。
	//由于只有两个元素，所以以{{1，2}，{3，4}，{5，6}}定义变量是超出范围的。
	int arr3[2][3] = { 1,2 };
	int arr4[2][3] = { {1},{2} };
	//注意两种定义方法的不同，第一种相当于{{1，2，0}，{0，0，0}}；第二种相当于{{1，0，0}，{2，0，0}}
	//第一个中括号内表示的是元素个数，int+第二个中括号代表类型
	int arr5[][3] = { 1,2,3,4 };
	//int arr6[2][] = { 1,2,3,4 };//元素个数可以不写，会根据程序定义的自动识别，但是类型是不可以缺少的~

	//int(* p1)[2][3] = &arr2;//arr2的地址★				{{1，2，3}，{4，5，6}}的地址
	//int(* p2)[3] = arr2;//arr2首元素的地址★				{1，2，3}的地址
	//int* p3 = *arr2;//对arr2间接引用得到首元素的地址★		{1}的地址
	//int p4 = *arr2[0];//对*arr2间接引用得到首元素的内容★	{1}

	//遍历二维数组需要两次遍历
	int i, j;
	for (i=0;i<2;i++)
	{
		for (j=0;j<3;j++)
		{
			printf("%d\n", arr1[i][j]);
			//arr1[0][0]可以理解成：间接引用得到{1}的地址，再间接引用得到内容{1}；arr[i][j]以此类推；
		}
	}
	return 0;
}
*/

